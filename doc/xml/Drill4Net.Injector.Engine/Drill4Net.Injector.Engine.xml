<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Drill4Net.Injector.Engine</name>
    </assembly>
    <members>
        <member name="T:Drill4Net.Injector.Engine.AssemblyInjector">
            <summary>
            The concrete Injector which injects the instrumenting code called by Target for Agent
            </summary>
        </member>
        <member name="P:Drill4Net.Injector.Engine.AssemblyInjector.Strategy">
            <summary>
            Concrete strategy of instrumenting code injections into Target
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyInjector.#ctor(Drill4Net.Injector.Core.CodeHandlerStrategy)">
            <summary>
            Create the Injector which injects the instrumenting code called by Target for Agent
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyInjector.Inject(Drill4Net.Injector.Core.RunContext,Drill4Net.Injector.Core.AssemblyContext)">
            <summary>
            Inject the specified assembly
            </summary>
            <param name="runCtx">Context of Injector Engine's Run</param>
            <param name="asmCtx">Context of current assembly</param>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyInjector.InjectProxyCalls(Drill4Net.Injector.Core.AssemblyContext,Drill4Net.Profiling.Tree.InjectedSolution)">
            <summary>
            Inject instrumenting probe calls of Proxy class' calls 
            for each needed cross-point of Target
            </summary>
            <param name="asmCtx">Assembly's context</param>
            <param name="tree">The tree of the injected entities</param>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyInjector.CorrectJumps(System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
             <summary>
            EACH short form of jumps to long form (otherwise, we need to recalculate 
            again after each necessary conversion)
             </summary>
             <param name="jumpers"></param>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyInjector.HandleInstruction(Drill4Net.Injector.Core.MethodContext)">
            <summary>
            Process the current instruction of IL code according to <see cref="P:Drill4Net.Injector.Engine.AssemblyInjector.Strategy"/>
            </summary>
            <param name="ctx">Current method context</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyInjector.InjectProxyType(Drill4Net.Injector.Core.RunContext,Drill4Net.Injector.Core.AssemblyContext)">
            <summary>
            Inject into assembly the Proxy class (it just pushes the probe data from 
            Target class to real Agent) according specified in context and options metadata
            </summary>
            <param name="runCtx">The Injector Engine's Run</param>
            <param name="asmCtx">Assembly context</param>
            <param name="opts">Injector options</param>
        </member>
        <member name="T:Drill4Net.Injector.Engine.AssemblyHelper">
            <summary>
            Helper for getting some info about assemblies
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyHelper.PrepareInjectedAssembly(Drill4Net.Injector.Core.RunContext,Drill4Net.Injector.Core.AssemblyContext)">
            <summary>
            Create and prepare the <see cref="T:Drill4Net.Profiling.Tree.InjectedAssembly"/> and its <see cref="T:Drill4Net.Profiling.Tree.InjectedDirectory"/> if needed
            </summary>
            <param name="runCtx">Context of the Injector Engine's Run</param>
            <param name="asmCtx">Assembly's context</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.AssemblyHelper.CalcBusinessIndex(Drill4Net.Injector.Core.MethodContext,System.Int32)">
            <summary>
            Calculates the index of the cross-point's instruction in the ideal business code 
            (collected from the compiler generated parts of IL code) by local index of the instruction
            in these compiler generated methods and classes.
            </summary>
            <param name="ctx">The target method's context</param>
            <param name="origInd">Local index of the cross-point for original IL code.</param>
            <returns></returns>
        </member>
        <member name="T:Drill4Net.Injector.Engine.ContextHelper">
            <summary>
            Helper for working with some contexts
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.ContextHelper.PrepareContextData(Drill4Net.Injector.Core.RunContext,Drill4Net.Injector.Core.AssemblyContext)">
            <summary>
            Prepare the Run's and Assembly's contexts
            </summary>
            <param name="runCtx">Context of Injector Engine's Run</param>
            <param name="asmCtx">Context of current assembly</param>
            <returns>Does the context contain any methods of interest to us and is it worth taking it into account?</returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.ContextHelper.IsEnterReturnRestrict(Drill4Net.Injector.Core.RunContext,Drill4Net.Injector.Core.MethodContext)">
            <summary>
            Do we need restrict Enter and Return cross-point's injection?
            </summary>
            <param name="runCtx">Injector Engine's Run context</param>
            <param name="methCtx">Method's context</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.ContextHelper.CalcStartIndex(Drill4Net.Profiling.Tree.MethodSource,Mono.Cecil.Cil.MethodBody)">
            <summary>
            Calculate the start index (we need skip the start of instruction array, for example,
            for some compiler generated methods)
            </summary>
            <param name="methodSource"></param>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.ContextHelper.PrepareProxyCalls(Drill4Net.Injector.Core.AssemblyContext,Drill4Net.Common.InjectorOptions)">
            <summary>
            Prepare info about injector proxy class and its called method
            </summary>
            <param name="asmCtx"></param>
            <param name="opts"></param>
        </member>
        <member name="T:Drill4Net.Injector.Engine.InstructionHelper">
            <summary>
            Instruction helper
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InstructionHelper.ShortJumpToLong(Mono.Cecil.Cil.OpCode)">
            <summary>
            Converting the short form of an IL instruction to the long form in cases of "jumping too far"
            </summary>
            <param name="opCode"></param>
            <returns></returns>
        </member>
        <member name="T:Drill4Net.Injector.Engine.MethodHelper">
            <summary>
            Helper for getting info about methods
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.MethodHelper.CorrectMethodBusinessSize(System.Collections.Generic.Dictionary{System.String,Drill4Net.Profiling.Tree.InjectedMethod},Drill4Net.Profiling.Tree.InjectedMethod,System.String)">
            <summary>
            Corrects the "business" (logically full) size of IL code of the method by its own size and its callees.
            </summary>
            <param name="methods">The list of the assembly's methods for the searching the callee by its name.</param>
            <param name="caller">The caller which calls the callee.</param>
            <param name="calleeName">Name of the particular callee of the caller method.</param>
            <exception cref="T:System.ArgumentNullException">nameof(methods)</exception>
        </member>
        <member name="M:Drill4Net.Injector.Engine.MethodHelper.MapBusinessFunction(Drill4Net.Injector.Core.MethodContext)">
            <summary>
            Maps the business function to compiler generated ones.
            </summary>
            <param name="ctx">The method's context.</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.MethodHelper.TryGetBusinessMethod(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Tries the get business method from the the string data.
            </summary>
            <param name="typeName">Name of the type.</param>
            <param name="methodName">Name of the method.</param>
            <param name="isCompilerGenerated">if set to <c>true</c> the method is compiler generated.</param>
            <param name="isAsyncStateMachine">if set to <c>true</c> the method is located in asynchronous state machine.</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.MethodHelper.GetMethodType(Mono.Cecil.MethodDefinition)">
            <summary>
            Get the type of method by its semantic (ctor, normal, setter/getter, compiler generated, etc)
            </summary>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.MethodHelper.IsCompilerGeneratedType(Mono.Cecil.MethodDefinition)">
            <summary>
            Method's type is compiler generated
            </summary>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.MethodHelper.IsSpecialGeneratedMethod(Drill4Net.Profiling.Tree.MethodType)">
            <summary>
            Is the method special even for compiler generated ones? Currently it's for the adding and removing events
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.MethodHelper.GetMethodKey(System.String,System.String)">
            <summary>
            Gets the string method key for using in some dictionaries.
            </summary>
            <param name="typeFullname">The type fullname.</param>
            <param name="methodShortName">Short name of the method.</param>
            <returns></returns>
        </member>
        <member name="T:Drill4Net.Injector.Engine.ProxyHelper">
            <summary>
            Helper for working with info for a injecting Proxy class
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.ProxyHelper.CreateProxyNamespace">
            <summary>
            Get the type namespace for the injected proxy class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.ProxyHelper.CreateProxyMethodReference(Drill4Net.Injector.Core.AssemblyContext,Drill4Net.Common.InjectorOptions)">
            <summary>
            Creates the proxy method's call reference for the injecting into the target's code.
            </summary>
            <param name="asmCtx">The assembly context.</param>
            <param name="opts">The Injector options.</param>
            <returns></returns>
        </member>
        <member name="T:Drill4Net.Injector.Engine.StructureHelper">
            <summary>
            Helper for constructing the method block structure, for the further coverage calculations
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.StructureHelper.CalcMethodBlocks(Drill4Net.Injector.Core.AssemblyContext)">
            <summary>
            The calculating of the local code block coverage (cross-point's instruction ranges)
            fro assembly's methods
            </summary>
            <param name="asmCtx">Assembly context</param>
        </member>
        <member name="T:Drill4Net.Injector.Engine.TypeHelper">
            <summary>
            Helper for getting info about types
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.FilterTypes(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},Drill4Net.Common.SourceFilterOptions)">
            <summary>
            Get filtered types of assembly by specified options
            </summary>
            <param name="allTypes"></param>
            <param name="opts"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.GetMethods(Drill4Net.Injector.Core.TypeContext,Drill4Net.Common.ProbesOptions)">
            <summary>
            Get filtered methods for specified type by options in <paramref name="opts"/>. 
            All methods of the nested types will also be found.
            </summary>
            <param name="typeCtx">Type's context</param>
            <param name="opts">Options for method filtering</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.GetMethods(Drill4Net.Injector.Core.TypeContext,Mono.Cecil.TypeDefinition,Drill4Net.Common.ProbesOptions)">
            <summary>
            Get filtered methods for specified type (as root) and the nested type in <paramref name="linkType"/> by options in <paramref name="opts"/>.
            This method used for the recurse founding all methods for the <paramref name="rootTypeCtx"/>
            </summary>
            <param name="rootTypeCtx">Root type's context</param>
            <param name="linkType">Current nested type in the <paramref name="rootTypeCtx"/></param>
            <param name="opts">Options for the method filtering</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.IsEnumerable(Mono.Cecil.TypeDefinition)">
            <summary>
            Does the specified type implement the Enumerable interface?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.IsAsyncMachine(Mono.Cecil.TypeDefinition)">
            <summary>
            Does the specified type implement an asynchronous State Machine?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.FilterMethods(Mono.Cecil.TypeDefinition,Drill4Net.Common.ProbesOptions)">
            <summary>
            Filter methods of the type according options
            </summary>
            <param name="type">The type definition</param>
            <param name="probOpts">Options for the filtering</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.TryGetRealTypeName(Mono.Cecil.TypeDefinition)">
            <summary>
            Try to get real type name from compiler generated classes. Technically, 
            it will be upward search the "normal name" in the type parent's hierarchy.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.CreateTypeSource(Mono.Cecil.TypeDefinition)">
            <summary>
            Retreive some metadata for type
            </summary>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.TypeHelper.GetAccessType(Mono.Cecil.TypeDefinition)">
            <summary>
            Get access type of type
            </summary>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="T:Drill4Net.Injector.Engine.InjectorEngine">
            <summary>
            High-level Injector Engine working with target directories and files. 
            It injects the Agent's proxy code to the needed methods and produces 
            the Tree metadata of processed entities (directories, assemblies, 
            classes, methods, cross-points, etc)
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorEngine.#ctor(Drill4Net.Injector.Core.IInjectorRepository)">
            <summary>
            Create the Injector Engine working with target directories and files
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorEngine.Process">
            <summary>
            Inject the target accordingly by the current config from repository
            </summary>
            <returns>Tree of metadata for injected entities (processed directories, assemblies, 
            classes, methods, cross-points, etc)</returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorEngine.Process(Drill4Net.Common.InjectorOptions)">
            <summary>
             Inject the target accordingly by the config form parameters 
            </summary>
            <param name="opts">Config for target's injection</param>
            <returns>Tree data of injection (processed directories, assemblies, classes, methods, cross-points, and their meta-data)</returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorEngine.ProcessDirectory(Drill4Net.Injector.Core.RunContext)">
            <summary>
            Process directory from current Engine's context
            </summary>
            <param name="runCtx">Context of Engine's Run</param>
            <returns>Is the directory processed?</returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorEngine.ProcessFile(Drill4Net.Injector.Core.RunContext)">
             <summary>
             Process file from current Engine's context
             </summary>
             <param name="runCtx">Context of Engine's Run</param>
            <returns>Is the file processed?</returns>
        </member>
        <member name="T:Drill4Net.Injector.Engine.InjectorRepository">
            <summary>
            Injector Engine's repository (provides injection strategy, target assemblies, 
            injector for them, the reading/writing of resulting tree data, etc)
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.#ctor(System.String)">
            <summary>
            Create Injector Engine's repository (provides injection strategy, target assemblies, 
            injector for them, the reading/writing of resulting tree data, etc).
            </summary>
            <param name="cfgPath">Path to the config of injection</param>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.#ctor(System.String[])">
            <summary>
            Create Injector Engine's repository (provides injection strategy, target assemblies, 
            injector for them, the reading/writing of resulting tree data, etc)
            </summary>
            <param name="args">Input arguments from console, including path to config, etc</param>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.GetInjector">
            <summary>
            Get the concrete assembly injector
            </summary>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.GetStrategy">
            <summary>
            Get the strategy of Target injections
            </summary>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.GetProxyGenerator">
            <summary>
            Get the IL code generator of the injecting Proxy Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.CopySource(System.String,System.String,System.Collections.Generic.Dictionary{System.String,Drill4Net.Common.MonikerData})">
            <summary>
            Preliminary coping the source directories and files from source to destination 
            according to the needed monikers (framework versions)
            </summary>
            <param name="sourcePath">Source directory</param>
            <param name="destPath">destintation directory</param>
            <param name="monikers">Dictionary of framework versions monikers from <see cref="P:Drill4Net.Common.VersionOptions.Targets"/>.
            Key is moniker (for example, net5.0)</param>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.ValidateOptions">
            <summary>
            Validation for options from loaded config
            </summary>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.GetAssemblies(System.String)">
            <summary>
            Get assemblies (.dll and .exe) from the specified directory
            </summary>
            <param name="directory">Directory with Target assemblies</param>
            <returns></returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.TryGetAssemblyVersion(System.String)">
            <summary>
            Try to get framework version of assembly. In some cases,
            the version cannot be obtained.
            </summary>
            <param name="filePath">Path to the file of assembly</param>
            <returns>Version of assembly including other metadata</returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.ReadInjectedTree">
            <summary>
            Read the metadata of injected entities from file
            </summary>
            <returns>Tree data of injected entities (directories, assemblies, types, methods, etc)</returns>
        </member>
        <member name="M:Drill4Net.Injector.Engine.InjectorRepository.WriteInjectedTree(System.String,Drill4Net.Profiling.Tree.InjectedSolution)">
            <summary>
            Write metadata of injected entities (directories, assemblies, types, methods, etc) to the file
            </summary>
            <param name="path"></param>
            <param name="tree"></param>
        </member>
    </members>
</doc>
